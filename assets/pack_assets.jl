using Images
using FileIO
using Colors
using Printf

const N_BYTES_TOC_NAME = 16

palette = [
	RGB(0x00/0xFF, 0x00/0xFF, 0x00/0xFF),
	RGB(0x1F/0xFF, 0x17/0xFF, 0x0B/0xFF),
	RGB(0x17/0xFF, 0x0F/0xFF, 0x07/0xFF),
	RGB(0x4B/0xFF, 0x4B/0xFF, 0x4B/0xFF),
	RGB(0xFF/0xFF, 0xFF/0xFF, 0xFF/0xFF),
	RGB(0x1B/0xFF, 0x1B/0xFF, 0x1B/0xFF),
	RGB(0x13/0xFF, 0x13/0xFF, 0x13/0xFF),
	RGB(0x0B/0xFF, 0x0B/0xFF, 0x0B/0xFF),
	RGB(0x07/0xFF, 0x07/0xFF, 0x07/0xFF),
	RGB(0x2F/0xFF, 0x37/0xFF, 0x1F/0xFF),
	RGB(0x23/0xFF, 0x2B/0xFF, 0x0F/0xFF),
	RGB(0x17/0xFF, 0x1F/0xFF, 0x07/0xFF),
	RGB(0x0F/0xFF, 0x17/0xFF, 0x00/0xFF),
	RGB(0x4F/0xFF, 0x3B/0xFF, 0x2B/0xFF),
	RGB(0x47/0xFF, 0x33/0xFF, 0x23/0xFF),
	RGB(0x3F/0xFF, 0x2B/0xFF, 0x1B/0xFF),
	RGB(0xFF/0xFF, 0xB7/0xFF, 0xB7/0xFF),
	RGB(0xF7/0xFF, 0xAB/0xFF, 0xAB/0xFF),
	RGB(0xF3/0xFF, 0xA3/0xFF, 0xA3/0xFF),
	RGB(0xEB/0xFF, 0x97/0xFF, 0x97/0xFF),
	RGB(0xE7/0xFF, 0x8F/0xFF, 0x8F/0xFF),
	RGB(0xDF/0xFF, 0x87/0xFF, 0x87/0xFF),
	RGB(0xDB/0xFF, 0x7B/0xFF, 0x7B/0xFF),
	RGB(0xD3/0xFF, 0x73/0xFF, 0x73/0xFF),
	RGB(0xCB/0xFF, 0x6B/0xFF, 0x6B/0xFF),
	RGB(0xC7/0xFF, 0x63/0xFF, 0x63/0xFF),
	RGB(0xBF/0xFF, 0x5B/0xFF, 0x5B/0xFF),
	RGB(0xBB/0xFF, 0x57/0xFF, 0x57/0xFF),
	RGB(0xB3/0xFF, 0x4F/0xFF, 0x4F/0xFF),
	RGB(0xAF/0xFF, 0x47/0xFF, 0x47/0xFF),
	RGB(0xA7/0xFF, 0x3F/0xFF, 0x3F/0xFF),
	RGB(0xA3/0xFF, 0x3B/0xFF, 0x3B/0xFF),
	RGB(0x9B/0xFF, 0x33/0xFF, 0x33/0xFF),
	RGB(0x97/0xFF, 0x2F/0xFF, 0x2F/0xFF),
	RGB(0x8F/0xFF, 0x2B/0xFF, 0x2B/0xFF),
	RGB(0x8B/0xFF, 0x23/0xFF, 0x23/0xFF),
	RGB(0x83/0xFF, 0x1F/0xFF, 0x1F/0xFF),
	RGB(0x7F/0xFF, 0x1B/0xFF, 0x1B/0xFF),
	RGB(0x77/0xFF, 0x17/0xFF, 0x17/0xFF),
	RGB(0x73/0xFF, 0x13/0xFF, 0x13/0xFF),
	RGB(0x6B/0xFF, 0x0F/0xFF, 0x0F/0xFF),
	RGB(0x67/0xFF, 0x0B/0xFF, 0x0B/0xFF),
	RGB(0x5F/0xFF, 0x07/0xFF, 0x07/0xFF),
	RGB(0x5B/0xFF, 0x07/0xFF, 0x07/0xFF),
	RGB(0x53/0xFF, 0x07/0xFF, 0x07/0xFF),
	RGB(0x4F/0xFF, 0x00/0xFF, 0x00/0xFF),
	RGB(0x47/0xFF, 0x00/0xFF, 0x00/0xFF),
	RGB(0x43/0xFF, 0x00/0xFF, 0x00/0xFF),
	RGB(0xFF/0xFF, 0xEB/0xFF, 0xDF/0xFF),
	RGB(0xFF/0xFF, 0xE3/0xFF, 0xD3/0xFF),
	RGB(0xFF/0xFF, 0xDB/0xFF, 0xC7/0xFF),
	RGB(0xFF/0xFF, 0xD3/0xFF, 0xBB/0xFF),
	RGB(0xFF/0xFF, 0xCF/0xFF, 0xB3/0xFF),
	RGB(0xFF/0xFF, 0xC7/0xFF, 0xA7/0xFF),
	RGB(0xFF/0xFF, 0xBF/0xFF, 0x9B/0xFF),
	RGB(0xFF/0xFF, 0xBB/0xFF, 0x93/0xFF),
	RGB(0xFF/0xFF, 0xB3/0xFF, 0x83/0xFF),
	RGB(0xF7/0xFF, 0xAB/0xFF, 0x7B/0xFF),
	RGB(0xEF/0xFF, 0xA3/0xFF, 0x73/0xFF),
	RGB(0xE7/0xFF, 0x9B/0xFF, 0x6B/0xFF),
	RGB(0xDF/0xFF, 0x93/0xFF, 0x63/0xFF),
	RGB(0xD7/0xFF, 0x8B/0xFF, 0x5B/0xFF),
	RGB(0xCF/0xFF, 0x83/0xFF, 0x53/0xFF),
	RGB(0xCB/0xFF, 0x7F/0xFF, 0x4F/0xFF),
	RGB(0xBF/0xFF, 0x7B/0xFF, 0x4B/0xFF),
	RGB(0xB3/0xFF, 0x73/0xFF, 0x47/0xFF),
	RGB(0xAB/0xFF, 0x6F/0xFF, 0x43/0xFF),
	RGB(0xA3/0xFF, 0x6B/0xFF, 0x3F/0xFF),
	RGB(0x9B/0xFF, 0x63/0xFF, 0x3B/0xFF),
	RGB(0x8F/0xFF, 0x5F/0xFF, 0x37/0xFF),
	RGB(0x87/0xFF, 0x57/0xFF, 0x33/0xFF),
	RGB(0x7F/0xFF, 0x53/0xFF, 0x2F/0xFF),
	RGB(0x77/0xFF, 0x4F/0xFF, 0x2B/0xFF),
	RGB(0x6B/0xFF, 0x47/0xFF, 0x27/0xFF),
	RGB(0x5F/0xFF, 0x43/0xFF, 0x23/0xFF),
	RGB(0x53/0xFF, 0x3F/0xFF, 0x1F/0xFF),
	RGB(0x4B/0xFF, 0x37/0xFF, 0x1B/0xFF),
	RGB(0x3F/0xFF, 0x2F/0xFF, 0x17/0xFF),
	RGB(0x33/0xFF, 0x2B/0xFF, 0x13/0xFF),
	RGB(0x2B/0xFF, 0x23/0xFF, 0x0F/0xFF),
	RGB(0xEF/0xFF, 0xEF/0xFF, 0xEF/0xFF),
	RGB(0xE7/0xFF, 0xE7/0xFF, 0xE7/0xFF),
	RGB(0xDF/0xFF, 0xDF/0xFF, 0xDF/0xFF),
	RGB(0xDB/0xFF, 0xDB/0xFF, 0xDB/0xFF),
	RGB(0xD3/0xFF, 0xD3/0xFF, 0xD3/0xFF),
	RGB(0xCB/0xFF, 0xCB/0xFF, 0xCB/0xFF),
	RGB(0xC7/0xFF, 0xC7/0xFF, 0xC7/0xFF),
	RGB(0xBF/0xFF, 0xBF/0xFF, 0xBF/0xFF),
	RGB(0xB7/0xFF, 0xB7/0xFF, 0xB7/0xFF),
	RGB(0xB3/0xFF, 0xB3/0xFF, 0xB3/0xFF),
	RGB(0xAB/0xFF, 0xAB/0xFF, 0xAB/0xFF),
	RGB(0xA7/0xFF, 0xA7/0xFF, 0xA7/0xFF),
	RGB(0x9F/0xFF, 0x9F/0xFF, 0x9F/0xFF),
	RGB(0x97/0xFF, 0x97/0xFF, 0x97/0xFF),
	RGB(0x93/0xFF, 0x93/0xFF, 0x93/0xFF),
	RGB(0x8B/0xFF, 0x8B/0xFF, 0x8B/0xFF),
	RGB(0x83/0xFF, 0x83/0xFF, 0x83/0xFF),
	RGB(0x7F/0xFF, 0x7F/0xFF, 0x7F/0xFF),
	RGB(0x77/0xFF, 0x77/0xFF, 0x77/0xFF),
	RGB(0x6F/0xFF, 0x6F/0xFF, 0x6F/0xFF),
	RGB(0x6B/0xFF, 0x6B/0xFF, 0x6B/0xFF),
	RGB(0x63/0xFF, 0x63/0xFF, 0x63/0xFF),
	RGB(0x5B/0xFF, 0x5B/0xFF, 0x5B/0xFF),
	RGB(0x57/0xFF, 0x57/0xFF, 0x57/0xFF),
	RGB(0x4F/0xFF, 0x4F/0xFF, 0x4F/0xFF),
	RGB(0x47/0xFF, 0x47/0xFF, 0x47/0xFF),
	RGB(0x43/0xFF, 0x43/0xFF, 0x43/0xFF),
	RGB(0x3B/0xFF, 0x3B/0xFF, 0x3B/0xFF),
	RGB(0x37/0xFF, 0x37/0xFF, 0x37/0xFF),
	RGB(0x2F/0xFF, 0x2F/0xFF, 0x2F/0xFF),
	RGB(0x27/0xFF, 0x27/0xFF, 0x27/0xFF),
	RGB(0x23/0xFF, 0x23/0xFF, 0x23/0xFF),
	RGB(0x77/0xFF, 0xFF/0xFF, 0x6F/0xFF),
	RGB(0x6F/0xFF, 0xEF/0xFF, 0x67/0xFF),
	RGB(0x67/0xFF, 0xDF/0xFF, 0x5F/0xFF),
	RGB(0x5F/0xFF, 0xCF/0xFF, 0x57/0xFF),
	RGB(0x5B/0xFF, 0xBF/0xFF, 0x4F/0xFF),
	RGB(0x53/0xFF, 0xAF/0xFF, 0x47/0xFF),
	RGB(0x4B/0xFF, 0x9F/0xFF, 0x3F/0xFF),
	RGB(0x43/0xFF, 0x93/0xFF, 0x37/0xFF),
	RGB(0x3F/0xFF, 0x83/0xFF, 0x2F/0xFF),
	RGB(0x37/0xFF, 0x73/0xFF, 0x2B/0xFF),
	RGB(0x2F/0xFF, 0x63/0xFF, 0x23/0xFF),
	RGB(0x27/0xFF, 0x53/0xFF, 0x1B/0xFF),
	RGB(0x1F/0xFF, 0x43/0xFF, 0x17/0xFF),
	RGB(0x17/0xFF, 0x33/0xFF, 0x0F/0xFF),
	RGB(0x13/0xFF, 0x23/0xFF, 0x0B/0xFF),
	RGB(0x0B/0xFF, 0x17/0xFF, 0x07/0xFF),
	RGB(0xBF/0xFF, 0xA7/0xFF, 0x8F/0xFF),
	RGB(0xB7/0xFF, 0x9F/0xFF, 0x87/0xFF),
	RGB(0xAF/0xFF, 0x97/0xFF, 0x7F/0xFF),
	RGB(0xA7/0xFF, 0x8F/0xFF, 0x77/0xFF),
	RGB(0x9F/0xFF, 0x87/0xFF, 0x6F/0xFF),
	RGB(0x9B/0xFF, 0x7F/0xFF, 0x6B/0xFF),
	RGB(0x93/0xFF, 0x7B/0xFF, 0x63/0xFF),
	RGB(0x8B/0xFF, 0x73/0xFF, 0x5B/0xFF),
	RGB(0x83/0xFF, 0x6B/0xFF, 0x57/0xFF),
	RGB(0x7B/0xFF, 0x63/0xFF, 0x4F/0xFF),
	RGB(0x77/0xFF, 0x5F/0xFF, 0x4B/0xFF),
	RGB(0x6F/0xFF, 0x57/0xFF, 0x43/0xFF),
	RGB(0x67/0xFF, 0x53/0xFF, 0x3F/0xFF),
	RGB(0x5F/0xFF, 0x4B/0xFF, 0x37/0xFF),
	RGB(0x57/0xFF, 0x43/0xFF, 0x33/0xFF),
	RGB(0x53/0xFF, 0x3F/0xFF, 0x2F/0xFF),
	RGB(0x9F/0xFF, 0x83/0xFF, 0x63/0xFF),
	RGB(0x8F/0xFF, 0x77/0xFF, 0x53/0xFF),
	RGB(0x83/0xFF, 0x6B/0xFF, 0x4B/0xFF),
	RGB(0x77/0xFF, 0x5F/0xFF, 0x3F/0xFF),
	RGB(0x67/0xFF, 0x53/0xFF, 0x33/0xFF),
	RGB(0x5B/0xFF, 0x47/0xFF, 0x2B/0xFF),
	RGB(0x4F/0xFF, 0x3B/0xFF, 0x23/0xFF),
	RGB(0x43/0xFF, 0x33/0xFF, 0x1B/0xFF),
	RGB(0x7B/0xFF, 0x7F/0xFF, 0x63/0xFF),
	RGB(0x6F/0xFF, 0x73/0xFF, 0x57/0xFF),
	RGB(0x67/0xFF, 0x6B/0xFF, 0x4F/0xFF),
	RGB(0x5B/0xFF, 0x63/0xFF, 0x47/0xFF),
	RGB(0x53/0xFF, 0x57/0xFF, 0x3B/0xFF),
	RGB(0x47/0xFF, 0x4F/0xFF, 0x33/0xFF),
	RGB(0x3F/0xFF, 0x47/0xFF, 0x2B/0xFF),
	RGB(0x37/0xFF, 0x3F/0xFF, 0x27/0xFF),
	RGB(0xFF/0xFF, 0xFF/0xFF, 0x73/0xFF),
	RGB(0xEB/0xFF, 0xDB/0xFF, 0x57/0xFF),
	RGB(0xD7/0xFF, 0xBB/0xFF, 0x43/0xFF),
	RGB(0xC3/0xFF, 0x9B/0xFF, 0x2F/0xFF),
	RGB(0xAF/0xFF, 0x7B/0xFF, 0x1F/0xFF),
	RGB(0x9B/0xFF, 0x5B/0xFF, 0x13/0xFF),
	RGB(0x87/0xFF, 0x43/0xFF, 0x07/0xFF),
	RGB(0x73/0xFF, 0x2B/0xFF, 0x00/0xFF),
	RGB(0xFF/0xFF, 0xFF/0xFF, 0xFF/0xFF),
	RGB(0xFF/0xFF, 0xDB/0xFF, 0xDB/0xFF),
	RGB(0xFF/0xFF, 0xBB/0xFF, 0xBB/0xFF),
	RGB(0xFF/0xFF, 0x9B/0xFF, 0x9B/0xFF),
	RGB(0xFF/0xFF, 0x7B/0xFF, 0x7B/0xFF),
	RGB(0xFF/0xFF, 0x5F/0xFF, 0x5F/0xFF),
	RGB(0xFF/0xFF, 0x3F/0xFF, 0x3F/0xFF),
	RGB(0xFF/0xFF, 0x1F/0xFF, 0x1F/0xFF),
	RGB(0xFF/0xFF, 0x00/0xFF, 0x00/0xFF),
	RGB(0xEF/0xFF, 0x00/0xFF, 0x00/0xFF),
	RGB(0xE3/0xFF, 0x00/0xFF, 0x00/0xFF),
	RGB(0xD7/0xFF, 0x00/0xFF, 0x00/0xFF),
	RGB(0xCB/0xFF, 0x00/0xFF, 0x00/0xFF),
	RGB(0xBF/0xFF, 0x00/0xFF, 0x00/0xFF),
	RGB(0xB3/0xFF, 0x00/0xFF, 0x00/0xFF),
	RGB(0xA7/0xFF, 0x00/0xFF, 0x00/0xFF),
	RGB(0x9B/0xFF, 0x00/0xFF, 0x00/0xFF),
	RGB(0x8B/0xFF, 0x00/0xFF, 0x00/0xFF),
	RGB(0x7F/0xFF, 0x00/0xFF, 0x00/0xFF),
	RGB(0x73/0xFF, 0x00/0xFF, 0x00/0xFF),
	RGB(0x67/0xFF, 0x00/0xFF, 0x00/0xFF),
	RGB(0x5B/0xFF, 0x00/0xFF, 0x00/0xFF),
	RGB(0x4F/0xFF, 0x00/0xFF, 0x00/0xFF),
	RGB(0x43/0xFF, 0x00/0xFF, 0x00/0xFF),
	RGB(0xE7/0xFF, 0xE7/0xFF, 0xFF/0xFF),
	RGB(0xC7/0xFF, 0xC7/0xFF, 0xFF/0xFF),
	RGB(0xAB/0xFF, 0xAB/0xFF, 0xFF/0xFF),
	RGB(0x8F/0xFF, 0x8F/0xFF, 0xFF/0xFF),
	RGB(0x73/0xFF, 0x73/0xFF, 0xFF/0xFF),
	RGB(0x53/0xFF, 0x53/0xFF, 0xFF/0xFF),
	RGB(0x37/0xFF, 0x37/0xFF, 0xFF/0xFF),
	RGB(0x1B/0xFF, 0x1B/0xFF, 0xFF/0xFF),
	RGB(0x00/0xFF, 0x00/0xFF, 0xFF/0xFF),
	RGB(0x00/0xFF, 0x00/0xFF, 0xE3/0xFF),
	RGB(0x00/0xFF, 0x00/0xFF, 0xCB/0xFF),
	RGB(0x00/0xFF, 0x00/0xFF, 0xB3/0xFF),
	RGB(0x00/0xFF, 0x00/0xFF, 0x9B/0xFF),
	RGB(0x00/0xFF, 0x00/0xFF, 0x83/0xFF),
	RGB(0x00/0xFF, 0x00/0xFF, 0x6B/0xFF),
	RGB(0x00/0xFF, 0x00/0xFF, 0x53/0xFF),
	RGB(0xFF/0xFF, 0xFF/0xFF, 0xFF/0xFF),
	RGB(0xFF/0xFF, 0xEB/0xFF, 0xDB/0xFF),
	RGB(0xFF/0xFF, 0xD7/0xFF, 0xBB/0xFF),
	RGB(0xFF/0xFF, 0xC7/0xFF, 0x9B/0xFF),
	RGB(0xFF/0xFF, 0xB3/0xFF, 0x7B/0xFF),
	RGB(0xFF/0xFF, 0xA3/0xFF, 0x5B/0xFF),
	RGB(0xFF/0xFF, 0x8F/0xFF, 0x3B/0xFF),
	RGB(0xFF/0xFF, 0x7F/0xFF, 0x1B/0xFF),
	RGB(0xF3/0xFF, 0x73/0xFF, 0x17/0xFF),
	RGB(0xEB/0xFF, 0x6F/0xFF, 0x0F/0xFF),
	RGB(0xDF/0xFF, 0x67/0xFF, 0x0F/0xFF),
	RGB(0xD7/0xFF, 0x5F/0xFF, 0x0B/0xFF),
	RGB(0xCB/0xFF, 0x57/0xFF, 0x07/0xFF),
	RGB(0xC3/0xFF, 0x4F/0xFF, 0x00/0xFF),
	RGB(0xB7/0xFF, 0x47/0xFF, 0x00/0xFF),
	RGB(0xAF/0xFF, 0x43/0xFF, 0x00/0xFF),
	RGB(0xFF/0xFF, 0xFF/0xFF, 0xFF/0xFF),
	RGB(0xFF/0xFF, 0xFF/0xFF, 0xD7/0xFF),
	RGB(0xFF/0xFF, 0xFF/0xFF, 0xB3/0xFF),
	RGB(0xFF/0xFF, 0xFF/0xFF, 0x8F/0xFF),
	RGB(0xFF/0xFF, 0xFF/0xFF, 0x6B/0xFF),
	RGB(0xFF/0xFF, 0xFF/0xFF, 0x47/0xFF),
	RGB(0xFF/0xFF, 0xFF/0xFF, 0x23/0xFF),
	RGB(0xFF/0xFF, 0xFF/0xFF, 0x00/0xFF),
	RGB(0xA7/0xFF, 0x3F/0xFF, 0x00/0xFF),
	RGB(0x9F/0xFF, 0x37/0xFF, 0x00/0xFF),
	RGB(0x93/0xFF, 0x2F/0xFF, 0x00/0xFF),
	RGB(0x87/0xFF, 0x23/0xFF, 0x00/0xFF),
	RGB(0x4F/0xFF, 0x3B/0xFF, 0x27/0xFF),
	RGB(0x43/0xFF, 0x2F/0xFF, 0x1B/0xFF),
	RGB(0x37/0xFF, 0x23/0xFF, 0x13/0xFF),
	RGB(0x2F/0xFF, 0x1B/0xFF, 0x0B/0xFF),
	RGB(0x00/0xFF, 0x00/0xFF, 0x53/0xFF),
	RGB(0x00/0xFF, 0x00/0xFF, 0x47/0xFF),
	RGB(0x00/0xFF, 0x00/0xFF, 0x3B/0xFF),
	RGB(0x00/0xFF, 0x00/0xFF, 0x2F/0xFF),
	RGB(0x00/0xFF, 0x00/0xFF, 0x23/0xFF),
	RGB(0x00/0xFF, 0x00/0xFF, 0x17/0xFF),
	RGB(0x00/0xFF, 0x00/0xFF, 0x0B/0xFF),
	RGB(0x00/0xFF, 0x00/0xFF, 0x00/0xFF),
	RGB(0xFF/0xFF, 0x9F/0xFF, 0x43/0xFF),
	RGB(0xFF/0xFF, 0xE7/0xFF, 0x4B/0xFF),
	RGB(0xFF/0xFF, 0x7B/0xFF, 0xFF/0xFF),
	RGB(0xFF/0xFF, 0x00/0xFF, 0xFF/0xFF),
	RGB(0xCF/0xFF, 0x00/0xFF, 0xCF/0xFF),
	RGB(0x9F/0xFF, 0x00/0xFF, 0x9B/0xFF),
	RGB(0x6F/0xFF, 0x00/0xFF, 0x6B/0xFF),
	RGB(0xA7/0xFF, 0x6B/0xFF, 0x6B/0xFF),
]

palette_lab = convert.(Lab, palette)

function signed_angle_dist(a, b)
	return atan(sin(b - a), cos(b - a))
end

function abs_angle_dist(a, b)
	return abs(signed_angle_dist(a, b))
end

# https://en.wikipedia.org/wiki/Color_difference#CIE94
function color_distance_cie94(A, B)
	kℓ = 1.0
	kc = 1.0
	kH = 1.0
	K₁ = 0.045
	K₂ = 0.015

	C₁ = hypot(A.a, A.b)
	C₂ = hypot(B.a, B.b)
	ΔC = C₁ - C₂
	ΔL = A.l - B.l
	Δa = A.a - B.a
	Δb = A.b - B.b
	ΔH = sqrt(max(Δa^2 + Δb^2 - ΔC^2,0.0)) # TODO
	SL = 1.0
	SC = 1.0 + K₁*C₁
	SH = 1.0 + K₂*C₁

	return sqrt((ΔL/(kℓ*SL))^2 + (ΔC/(kc*SC))^2 + (ΔH/(kH*SH))^2)
end

function get_closest_color_in_palette(color, palette::Vector{T}) where T <: Lab
	color_lab = convert(Lab, color)

	min_dist = Inf
	best_index = 0
	for (i, candidate) in enumerate(palette)

		dist = color_distance_cie94(color_lab, candidate)

		if dist < min_dist
			min_dist = dist
			best_index = i
		end
	end

	return best_index
end


tiles = UInt8[
    1 1 1 1 1 1 1 1 2 1 1 1 2;
    1 0 0 0 0 0 0 1 2 0 0 0 2;
    1 0 0 3 0 0 2 2 2 0 0 0 2;
    1 0 0 0 0 0 0 0 0 0 0 0 2;
    1 0 0 0 0 0 2 2 2 0 0 0 2;
    1 0 2 0 0 0 0 1 2 0 0 0 2;
    1 0 0 0 0 0 0 1 2 0 0 0 2;
    1 1 1 1 1 1 1 1 2 3 3 3 2]

floor = UInt8[
    1 1 1 1 1 1 1 1 2 1 1 1 2;
    1 4 4 4 4 4 4 1 2 5 5 5 2;
    1 4 4 3 4 4 2 2 2 5 5 5 2;
    1 4 4 4 4 4 2 2 2 5 5 5 2;
    1 4 4 4 4 4 2 2 2 5 5 5 2;
    1 4 2 4 4 4 4 1 2 5 5 5 2;
    1 4 4 4 4 4 4 1 2 5 5 5 2;
    1 1 1 1 1 1 1 1 2 3 3 3 2]

ceiling = UInt8[
    1 1 1 1 1 1 1 1 2 1 1 1 2;
    1 4 4 4 4 4 4 1 2 4 4 4 2;
    1 4 4 3 4 4 2 2 2 4 4 4 2;
    1 4 4 4 4 4 2 2 2 4 4 4 2;
    1 4 4 4 4 4 2 2 2 4 4 4 2;
    1 4 2 4 4 4 4 1 2 4 4 4 2;
    1 4 4 4 4 4 4 1 2 4 4 4 2;
    1 1 1 1 1 1 1 1 2 3 3 3 2]

# The output format is:
# HEADER:
#    "TOOM"   - 4 chars
# Data:
#   necessary data, laid out as needed.
# Table of Contents:
#   array of table of content entries:
#      u32       offset in file # number of bytes past 'TOOM' to read at. First entry will have offset 0
#      char[16]  name           # null-terminated string label, e.g. "floor_textures"
#   u32 n_toc_entries = number of table of content entries

struct TableOfContentsEntry
	name::String
	offset_in_file::UInt32
end

function write_image(img, output::IOStream; column_major::Bool=true)::UInt32
	n_bytes_written = zero(UInt32)

	# Write the number of pixels as a UInt32
	n_pixels = UInt32(length(img))
	write(output, n_pixels::UInt32)
	n_bytes_written += 4

	# Write the number of pixels per column as a UInt32
	n_pix_per_column = UInt32(size(img)[1])
	write(output, n_pix_per_column::UInt32)
	n_bytes_written += 4

	# Write whether the pixels are in column major order
	write(output, UInt8(column_major))
	n_bytes_written += 1

	# Write the image top to bottom and left to right, as ABGR little endian
	if column_major
		# a11, a21, a31, a12, a22, a32, a31, a23, a33
		for col in 1:size(img)[2]
			for row in 1:n_pix_per_column
				write(output, (img[row, col].r.i)::UInt8)
				write(output, (img[row, col].g.i)::UInt8)
				write(output, (img[row, col].b.i)::UInt8)
				write(output, img[row, col] == RGB(1.0, 0.0, 1.0) ? 0x00 : 0xFF);
				n_bytes_written += 4
			end
		end
	else
		# a11, a12, a13, a21, a22, a23, a31, a32, a33
		for row in 1:n_pix_per_column
			for col in 1:size(img)[2]
				write(output, (img[row, col].r.i)::UInt8)
				write(output, (img[row, col].g.i)::UInt8)
				write(output, (img[row, col].b.i)::UInt8)
				write(output, img[row, col] == RGB(1.0, 0.0, 1.0) ? 0x00 : 0xFF);
				n_bytes_written += 4
			end
		end
	end

	return n_bytes_written
end

function write_map_data(
	tiles::Matrix{UInt8},
	floor::Matrix{UInt8},
	ceiling::Matrix{UInt8},
	output::IOStream)::UInt32

	@assert size(tiles) == size(floor)
	@assert size(tiles) == size(ceiling)

	n_bytes_written = zero(UInt32)

	# Write the number of tiles as a UInt32
	n_tiles = UInt32(length(tiles))
	write(output, n_tiles::UInt32)
	n_bytes_written += 4

	# Write the number of tiles per row as a UInt32
	n_pix_per_row = UInt32(size(tiles)[2])
	write(output, n_pix_per_row::UInt32)
	n_bytes_written += 4

	# Write out the tile values in row-major order.
	# a11, a12, a13, a21, a22, a23, a31, a32, a33
	for row in 1:size(tiles)[1]
		for col in 1:size(tiles)[2]
			write(output, tiles[row, col]::UInt8)
			n_bytes_written += 1
		end
	end

	# Write out the floor values in row-major order.
	# a11, a12, a13, a21, a22, a23, a31, a32, a33
	for row in 1:size(floor)[1]
		for col in 1:size(floor)[2]
			write(output, floor[row, col]::UInt8)
			n_bytes_written += 1
		end
	end

	# Write out the ceiling values in row-major order.
	# a11, a12, a13, a21, a22, a23, a31, a32, a33
	for row in 1:size(ceiling)[1]
		for col in 1:size(ceiling)[2]
			write(output, ceiling[row, col]::UInt8)
			n_bytes_written += 1
		end
	end

	return n_bytes_written
end

# struct Patch {
#     u16 size_x;      // width of the graphic in pixels
#     u16 size_y;      // height of the graphic in pixels
#     i16 offset_x;    // x offset from the screen origin (to left)
#     i16 offset_y;    // y offset from the screen origin (down)
#     u32 column_offsets[64];
# };


function write_patch(img, output::IOStream)::UInt32

	n_bytes_written = zero(UInt32)

	n_columns = UInt16(size(img)[2])
	n_pix_per_column = UInt16(size(img)[1])

	# Allocate the data ahead of time, so we can rewrite into it.
	# Then write it all out.
	# TODO: For now, just export all columns, even if they are empty
	data = zeros(UInt8, 8 + (8 + n_pix_per_column)*n_columns)
	buffer = IOBuffer(data, write=true)

	# Write the number of columns
	write(buffer, n_columns::UInt16)
	n_bytes_written += UInt32(2)

	# Write the number of pixels per column
	write(buffer, n_pix_per_column::UInt16)
	n_bytes_written += UInt32(2)

	# Write the left offset
	# TODO: For now, make it half the image
	write(buffer, Int16(n_columns >> 1))
	n_bytes_written += UInt32(2)

	# Write the vertical offset
	# TODO: For now, make it the full image
	write(buffer, Int16(n_pix_per_column))
	n_bytes_written += UInt32(2)

	# Skip over the column offsets
	n_bytes_written += UInt32(4*n_columns)
	for i in 1:n_columns
		write(buffer, zero(UInt32))
	end

	# Write the pixel columns according to the DOOM "post" format.
	# https://doomwiki.org/wiki/Picture_format
	# TODO: Check if a previous column matches one that we've already exported, so we don't need to have redundant data.
	for col in 1:n_columns

		# Set the column offset
		column_offset_idx = 8 + 4*(col-1)
		data[column_offset_idx+1] = UInt8(n_bytes_written       & 0xFF)
		data[column_offset_idx+2] = UInt8(n_bytes_written >> 8  & 0xFF)
		data[column_offset_idx+3] = UInt8(n_bytes_written >> 16 & 0xFF)
		data[column_offset_idx+4] = UInt8(n_bytes_written >> 24 & 0xFF)

		row = 1

		while row < 0xFF
			# Scan through pixels until we get an opaque pixel (or end-of-post).
			while row ≤ n_pix_per_column && img[row, col].alpha.i < 0x80 # transparent
				row += 1
			end

			# Write out the offset
			n_bytes_written += UInt32(1)
			if row > n_pix_per_column
				write(buffer, UInt8(0xFF))
				row = 0xFF
				break # terminate column
			else
				write(buffer, UInt8(row-1))
			end

			# Scan through pixels until we get a transparent pixel (or end-of-post).
			row_start = row
			while row ≤ n_pix_per_column && img[row, col].alpha.i ≥ 0x80 # opaque
				row += 1
			end

			# Write out the number of pixels in this post
			write(buffer, UInt8(row - row_start))
			n_bytes_written += UInt32(1)

			# Write out a padding byte
			write(buffer, UInt8(0))
			n_bytes_written += UInt32(1)

			# Write out the palettized color data
			for row_output in row_start:row-1
				color_idx = get_closest_color_in_palette(img[row_output, col], palette_lab) - 1 # C-style index
				write(buffer, UInt8(color_idx))
				n_bytes_written += UInt32(1)
			end

			# Write out a padding byte
			write(buffer, UInt8(0))
			n_bytes_written += UInt32(1)
		end
	end

	# Write the buffer to our output stream
	write(output, data[1:n_bytes_written])
	return n_bytes_written
end




offset_in_file = zero(UInt32)
table_of_contents_entries = TableOfContentsEntry[]

output_file = "assets.bin"
open(output_file, "w") do output
	write(output, 'T')
	write(output, 'O')
	write(output, 'O')
	write(output, 'M')

	global offset_in_file
	global table_of_contents_entries

	# ADD CONTENT ---------------------------------------
	push!(table_of_contents_entries, TableOfContentsEntry(
		"textures",
		offset_in_file
	))
	offset_in_file += write_image(load("textures.tif"), output, column_major=true)

	push!(table_of_contents_entries, TableOfContentsEntry(
		"stick",
		offset_in_file
	))
	offset_in_file += write_image(load("stick.tif"), output, column_major=true)

	push!(table_of_contents_entries, TableOfContentsEntry(
		"mapdata",
		offset_in_file
	))
	offset_in_file += write_map_data(tiles, floor, ceiling, output)

	for skel_index in 0:359
		push!(table_of_contents_entries, TableOfContentsEntry(
			@sprintf("SKEL%03d", skel_index),
			offset_in_file
		))
		img = load(@sprintf("skeleton/%04d.png", skel_index))
		offset_in_file += write_patch(img, output)
	end

	# WRITE TABLE OF CONTENTS -----------------------------

	for entry in table_of_contents_entries
		write(output, entry.offset_in_file)
		offset_in_file += 4

		for i in 1:N_BYTES_TOC_NAME-1
			c = '\0'
			if i ≤ length(entry.name)
				c = entry.name[i]
			end
			write(output, c)
		end
		write(output, '\0') # Always null-terminate
		offset_in_file += N_BYTES_TOC_NAME
	end

	write(output, UInt32(length(table_of_contents_entries)))
	offset_in_file += 4
end

println("Done!")
println("Total bytecount: ", offset_in_file + 4)